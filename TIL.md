220524

# 14장 전역 변수의 문제점

## 전역 변수의 문제점

- 암묵적 결함: 모든 코드가 전역 변수를 참조하고 변경할 수 있음
  -> 1. 변수의 유효범위가 크면 가독성이 나빠짐
  -> 2. 의도치 않은 상태 변화가 발생할 수 있음

- 긴 생명 주기
  -> 1. 메모리 리소스를 오랜 기간 잡아먹는다.(브라우저 상에서는 브라우저가 닫힐 때까지)
  -> 2. var는 특히 재할당이 가능하기 때문에 의도와는 다르게 값이 바뀔 수 있다.

- 스코프 체인 상 종점에 존재
  -> 변수 검색 시 가장 마지막에 검색됨

- 네임스페이스 오염
  -> 파일이 분리되어 있어도 하나의 전역 스코프 공유하기 때문에 문제 발생 가능성 있음 \*

## 전역 변수의 사용을 억제할 수 있는 방법

1. 즉시 실행 함수
   -> 모든 코드를 즉시 실행 함수로 감싸면 변수를 지역변수로 만들 수 있다.

2. 네임스페이스 객체
   -> 객체 안에 객체를 만들어 계층적으로 구성, 스코프를 줄일 수 있다.
   but, 네임스페이스 객체 자체가 전역 변수에 할당되므로 그닥.

3. 모듈 패턴 like 클래스
   변수와 함수를 모아 즉시 실행 함수로 감싸서 모듈을 만듦

- - 전역 변수의 억제 + 캡슐화

# 15장

## var

- 변수의 중복 선언 허용
- 함수 레벨 스코프(지역변수로 할당시) -> 함수 이외에선 전역변수로

## let

- 변수 중복 선언 금지 -> 같은 스코프 내 중복선언X
- 모든 코드블록을 지역스코프로 인정
- 호이스팅 발생X 처럼?! -> '선언단계', '초기화단계' 분리 -> 스코프 시작부터 초기화 이전까지 사용X
- 전역 객체(window) 프로퍼티X

## const

- 상수 선언 위해서
- const는 선언과 초기화 동시에
- 재할당X -> 원시 값 할당시 값 바뀌지 않음, 코드 가독성도 상승(의미부여)
- 객체는 값 변경 가능(참조형 데이터이기 때문에)

220525

# 8장: 제어문

## 알게된 것

> 문은 변수할당 불가능
> 식 -> 값으로 평가 할 수 있는 문 => 변수에 할당 가능!
> so, 삼항연산자는 표현식이므로 변수의 할당 가능!

## 블록문

- 0개 이상의 문을 중괄호로 묶은 것
- 블록문의 끝에는 자체적으로 종결의 의미가 있어 세미콜론을 붙이지 않음

## 조건문

- if ... else 문 -> 조건식의 평과 결과에 따라 불록문 실행, 조건이 불리언일 때 많이 사용
- switch 문 -> 표현식 평가 후 case 문으로 실행 흐름을 옮김, 표현식이 문자열이나 숫자열일 때 많이 사용

## 반복문

- for 문 -> 조건식이 거짓으로 평가될 때까지 코드 블록 반복, 반복 횟수가 정해져있을 때 많이 사용
- while 문 -> 조건식의 평가 결과가 참이면 코드 블록 반복, 반복 횟수가 정해져있지 않을 때 많이 사용

## break 문

- 코드 블록을 탈출

## continue 문

- 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름으 옮김

# 16장: 프로퍼티와 어트리뷰트

## 내부 슬롯, 내부 메서드

- JS의 엔진의 구현 알고리즘 설명을 위해 사용
- 직접 접근 불가능

## 프로퍼티 어트리뷰트, 프로퍼티 디스트립터 객체

- JS 엔진 -> 프로퍼티 생성 -> 프로퍼티 어트리뷰트 정의(프로퍼티의 상태): JS 엔진이 관리하는 내부 슬롯 - 직접 접근X
- 간접 접근 -> object.getOwnPropertyDescriptor(객체, 키) -> 프로퍼티 디스크립터 객체 반환(프로퍼티 어트리뷰트의 정보 제공)

## 데이터 프로퍼티

- 키, 벨류 값으로 구성
- value, writable, enumerable, configurable 프로퍼티 어트리뷰트를 가짐

## 접근자 프로퍼티

- 자체적 값X, 데이터 프로퍼티 값 읽거나 저장할 때 호출됨
- get, set, enumerable, configurable
- 데이터 프로퍼티 안에 있는 프로퍼티 -> 접근자를 통해 값을 읽거나 저장할 수 있음

=> 둘 구분 어떻게?

- object.getOwnPropertyDescriptor가 반환한 디스크립토 객체 확인

## 프로퍼티 정의?

- 프로퍼티 정의할 때 프로퍼티 어트리뷰트 선택 가능! (Object.defineProperty)

  > enumerable: false => 열거X(for ...)
  > writable: false => 값 변경X
  > configurable: false => 삭제X, 재정의X

- Objec.defineProperty로 프로퍼티 정의시 일부 어트리뷰트 생략가능

## 객체 변경 방지

- 객체는 변할 수 있는 값이기 때문에 변경 방지하는 메서드가 있음!
  > 확장X(객체확장X): Object.preventExtensions: 추가 금지(2가지: 동적, defineProperty), 삭제는 가능
  > 재정의X(객체밀봉): Object.seal -> 읽기와 쓰기만 가능
  > 읽기만 가능(객체 동결): Object.isFrozen
  > 중첩객체 동결(불변 객체): 재귀적 Object.freeze

## 정리 & 배운것

- 프로퍼티는 프로퍼티 상태를 나타내는 어트리뷰트를 가지고 있고 개발자는 그것을 원하는 대로 설정 가능 => 객체를 만들 때 원하는 대로 옵션을 선택할 수 있다!
- 마치, 스타크래프트에서 커세어는 공중 공격만 가능하고, 벌쳐는 지상 공격만 가능하다. 질럿은 근거리 공격만 되고, 마린은 원거리, 공중 다됨. 게임 유닛의 속성을 다르게 만들었듯이 객체도 속성을 다르게 설정 가능하다!

220527

# 17장: 생성자 함수에 의한 객체 생성

## 객체 생성 방식

1. 객체 리터럴로 생성

- 문제
  - 동일한 프로퍼티를 가진 객체를 여러 개 생성해야하는 경우 비효율적

2. new 연산자(생성자 함수)로 생성

- 장점
  - 프로퍼티 구조가 동일한 객체를 여러 개 생성할 때 간편

## 생성자 함수와 인스턴스

> 인스턴스 생성 과정

- 생성자 함수 역할
  1. 인스턴스 생성하기 위한 템플릿 역할
  2. 인스턴스를 초기화 하는 역할(프로퍼티 추가 or 초기값 할당)
- 생성자 함수를 호출하면 암묵적으로 인스턴스 생성 후 반환

1.  인스턴스와 this 바인딩

- 빈 객체가 생성되는데 그것은 인스턴스이다.
- 인스턴스는 this에 바인딩 된다.

2. 인스턴스 초기화

- 프로퍼티 추가 및 생성

3. 인스턴스 반환

- 암묵적으로 인스턴스가 바인딩된 this를 반환

`생성자 함수 내부에서는 return 생략!`

## 내부 메서드

- 함수는 객체이고 객체의 내부슬록과 내부메서드를 가지고 있다.
- 그리고 함수는 `[[Call]]`, `[[Constructor]]]`도 추가로 가지고 있는데
- 일반 함수는 호출 가능하기 때문에 call을 항상 가지고 있고 constructor는 선택

> constructor 구분

- constructor -> 함수 선언문, 함수 표현식, 클랙스
  ```
  // 함수 선언문
  function sum(a, b) {
    return a + b;
  }
  ```
  ```
  // 함수 선언문
    function sum(a, b) {
      return a + b;
    }
  ```
- non-constructor -> 메서드, 화살표 함수
  - 프로퍼티로 정의된 함수는 메서드로 인정X(일반 함수)

> new 연산자

    - 일반 함수의 return 문이 있다면 new 연산자로 인스턴스 생성시 빈 객체 반환함
    - 생성자 함수 구분을 위해 보통 생성자 함수는 파스칼 케이스로 명명

> new.target

    - new 연선자로 생성자 함수 호출 -> new.target은 함수 자신을 가리킴
    - 일반 함수로 호출 -> new.target은 undefined
    - 활용 -> new.target으로 new 연산자와 생성자 함수로서 호출했는지 확인 후 재귀 호출로 생성자 함수로서 호출 가능

# 18장: 함수와 일급 객체

## 일급 객체란 무엇인가?!

1. 무명의 리터럴 생성
2. 변수나 자료구조에 저장 가능
3. 함수의 매개변수에 전달 가능
4. 함수의 반환값으로 사용 가능

- 함수는 일급객체!

### 함수와 일반객체와의 차이

1. 함수는 호출 가능하다.
2. 함수 고유의 프로퍼티를 갖는다.

> 함수 고유의 프로퍼티

1. arguments 프로퍼티

- 매개변수로 전달된 인수의 정보를 담고 있는 순회가능한 유사배열객체(함수 내부에서 지역변수 처럼 사용 가능)

2. caller 프로퍼티

- 함수 자신을 호출한 함수를 가리킴

3. length 프로퍼티

- 함수를 정의할 때 선언한 매개변수의 개수를 가리킴

4. name 프로퍼티

- 함수의 이름을 나타냄
- 익명 함수일 때
  es5 -> 빈 배열
  es6 -> 함수 객체를 가리키는 식별자를 값으로 가짐

5. **proto** 접근자 프로퍼티

- 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티

6. prototype 프로퍼티

- 생성자 함수로 호출할 수 있는 함수 객체, constructor만 소유하는 프로퍼티

# 19장: 프로토타입

## 객체지향 프로그래밍

-> 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

> 객체

- 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조
- 상태 데이터(프로퍼티)와 동작(메서드)을 하나의 논리적인 단위로 묶은 복합적인 자로구조
- 고유한 기능을 수행하면서 다른 객체와의 관계성을 가짐

## 상속과 프로토타입

> 상속

- 어떤 객체의 프로퍼티와 메서드를 그대로 넘겨받아 사용할 수 있는 것
- 상속을 통해 중복 제거 - 공통 메서드를 인스턴스를 만들 때마다 생성하면 비효율적
  => 프로포타입으로 상속
  - 생성자 함수의 prototype 프로퍼티에 공통 메서드를 등록할 수 있음
  - 하나의 메서드를 필요할 때마다 상속받아 사용 가능!

## 프로포타입 객체

- 어떤 객체의 상위(부모)객체의 역할을 하는 객체 -> 공유 프로퍼티 제공
- 모든 객체는 `[[prototype]]` 내부 슬롯을 가짐(프로토타입의 참조) -> 객체 생성 방식에 따라 프로토타입 다름
- (`[[prototype]]` 안에 프로토타입이 저장됨)
  - 일반 객체 경우 -> 프로토타입은 Object.prototype
  - 생성자 함수의 경우 -> 생성자 함수의 prototype 프로퍼티에 있는 객체

> **proto** 접근자 프로퍼티

- 자신의 `[[prototype]]` 접근하기 위해 **prototype**을 간접적으로 사용할 수 있음
- 모든 객체는 **proto**를 통해 `[[prototype]]`에 간접적으로 접근 가능!(**proto** -> 프로토타입)
- 접근자 프로퍼티는 자체 값X, get/set 프로퍼티 어트리뷰트로 구성
- **proto** -> 값 지정: get, 값 할당: set
- Object.prototype의 프로퍼티(객체들이 공통으로 소유하는 것) -> 어던 객체의 프로퍼티가 없다면 타고타고 올라가 Object.prototype이 검색된다(프로포타입 체이닝)

> 프로토타입에 접근하려는 이유

- 상호참조에 의해 프로토타입 체인이 생성되는 것 막기 위해
- 프로토타입 체인은 단방향 링크드 리스트로 구현되어야함!

> **proto**로 접근 권장X -> 모든 객체가 **proto** 사용 가능X
> -> getPrototypeOf 메서드를 사용할 것

> 함수 객체의 prototype 프로퍼티

- 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킴
- non-constructor는 prototype 프로퍼티가 없다

> 모든 객체 -> **proto** - 객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용
> 함수 객체(constructor) -> prototype 프로퍼티 - 인스턴스의 프로토타입을 할당하기 위해 사용

> 프로토타입의 constructor 프로퍼티와 생성자 함수
> 인스턴스 -> prototype(constructor를 가짐) -> 생성자 함수

=> 인스턴스는 prototype의 constructor를 상속받아 사용 가능

## 프로토타입의 생성 시점

> 리터럴로 생성된 객체의 생성자 함수와 프로토타입은 쌍으로 존재하기 때문에 => 프로토타입은 생성자 함수가 생성되는 시점에 같이 생성된다.

## 빌트인과 사용자 정의 함수 프로토타입 생성 시점

> 사용자 정의 함수

- 생성자 함수 가장 먼저 실행 -> 함수 객체가 됨 -> 프로토타입도 같이 생성 -> 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩 됨
- 생성된 프로토타입은 언제나 Object.prototype

> 빌트인 생성자 함수

- 전역 객체가 생성되는 시점(코드실행전)에 프로토타입 생성됨! -> 생성된 프로토타입은 prototype 프로퍼티에 바인딩 됨
- 객체 생성 전 이미 생성자함수 프로토타입 존재하고 생성자 또는 리터럴로 객체가 생성하면 프로토타입은 해당 객체의 `[[Prototype]]` 내부슬롯에 할당됨

## 객체 생성방식과 프로토타입 결정

- OrginaryObjectCreate - 프로토타입을 만들어 객체에 전달해줌
- 프로토타입은 추상 연산 OrginaryObjectCreate에 전달되는 인수에 의해 결정됨

> 객체 생성방식에 따른 프로퍼티 추가 방식 차이

- 객체리터럴 -> 객체 리터럴 내부에 프로퍼티 추가
- 생성자함수 -> 일단 빈객체 생성, 프로퍼티 추가

## 프로토타입 체인

- JS가 객체지향 프로그래밍의 상속을 구현하는 메커니즘
- 객체의 메서드에 접근하려 할 때 `[[prototype]]` 내부 슬롯의 참조를 따라서 부모쪽으로 순차적으로 검색
- 프로토타입 체인을 통해 부모자식간 상속과 검색을 할 수 있음!
- 프로퍼티말고 식별자는 스코프 내에서 검색함!(스코프 체인 -> 스코프의 계층적 구조)
- 스코프 체인과 프로토타입 체인은 서로 협력하여 식별자와 프로퍼티 검색!

## 오버라이팅과 프로퍼티 섀도잉

- 상속관계에 의해 프로퍼티가 가려지는 현상

  - 프로토타입 메서드, 인스턴스 메서드

- 하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제 불가능
  (하극상X, 프로토타입에 직접 접근)

## 프로토타입 교체

1. 생성자 함수로 교체-> 객체 리처럴로 교체 -> constructor 없음
2. 인스턴스로 교체 -> `__proto__`를 통해 접근

## instanceof 연산자

- `객체 instanceof 생성자 함수`
  -> 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상 존재하는지

## 직접 상속

> Object.create 메서드: 객체를 생성하면서 직접적으로 상속 구현

> `__proto__` 로 상속: 객체 리터럴 내부에서 `__proto__` 접근자로 직접 상속 가능

## 정적 프로퍼티와 메서드

- 생성자 함수로 인스턴스를 생성하지 않아도 참조할 수 있는 프로퍼티와 메서드
  -> .staticMethod() - .함수() 형식으로 호출하는 함수

- 생성자 함수가 생성한 인스턴스로 참조 불가능 -> me.staticMethod() => 에러
  -> 정적 프로퍼티/메서드는 인스턴스의 프로토타입 체인에 속한 것이 아니므로 인스턴스로 접근X

- 프로토타입 메서드를 호출 하려면 -> 인스턴스 생성해야함 but 정적 메서드를 호출은 -> 인스턴스 생성 안해도됨!

## 프로퍼티 존재 확인

- in 연산자, Object.prototype.hasownProperty() 통해 객체 내 특정 프로퍼티 존재 여부 확인 가능!

## 프로퍼티 열거

> for ... in

- 객체의 모든 프로터치를 순회하며 열거, 열거문 안에 선언한 변수의 프로퍼티 키를 할당!
- 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 eumerable한 프로퍼티를 열거
- 객체 자신 프로퍼티 + 상속받은 프로퍼티도 열거
- 프로퍼티 열거시 순서보장X

> Object.keys.entries 메서드를 통해 자신의 고유한 프로퍼티만 열거 가능하다.

## ESLint

- 린트 도구는 코드를 점검하는 툴이다.
- 소스코드 실행 전 문법적 오류 + 잠재적 오류까지 확인해줌

# 21장: 빌트인 객체
> 표준 빌트인 객체, 호스트 객체, 사용자 정의 객체

## 표준 빌트인 객체
- 인스턴스를 생성할 수 있는 생성자 함수 객체 -> 프로토타입 메서드 + 정적 메서드

```JS
const numObj = new Number(1.5); // Number {1.5}
console.log(numObj.tofixed()); // 2
console.log(Number.isInteger(0.5)) // false
```

## 원시값이 객체처럼?
```JS
const str = 'hello';
console.log(str.length); // 5
console.log(str.toUpperCase()); // HELLO
```
- 마침표 표기법 사용시 **JS엔진이 원시 값을 연관된 객체로 변환하고 다시 되돌림!**
- 상속받을 수도 있음!(임시객체인 **래퍼 객체** 적용)
- 그래서 String, Number, Boolean은 생성자 함수로 사용하는 것은 권장X 

## 전역 객체
- 어떤 객체에도 속하지 않는 모든 빌트인 객체의 최상위 객체
- 전역 객체의 프로퍼티
  - var 전역 변수 -> 전역 변수X, 전역 객체의 프로퍼티
  - 암묵적 전역
  - 전역 함수

## 빌트인 전역 함수
> ecncodeURI -> 이스케이프 처리하여 인코딩
  - 아스키 문자 셋으로 변환하여 모든 시스템에서 읽을 수 있게 처리!
  - 한글은 URL에 적용X, 한글을 인코딩하면 이스케이프 처리됨

## 암묵적 전역
  
  - 마치 선언된 전역 번수처럼 동작 -> 전역 객체의 프로퍼티가 됨!
  - but 변수X -> 호이스팅X'
  - delete로 삭제O

# 22장: this

## this 키워드!
- 생성할 인스턴스를 가리치는 특수한 식별자!
- 생성자 함수를 정의할 때는 인스턴스 정의하기 전! -> 그래서 식별자가 필요함

- 특징
  - this에 연결되는 것은 함수 호출 방식에 동적으로 결정됨!
  - 객체 리터럴 메서드 내부 -> 메서드 호출한 객체
  - 생성자 함수 내부 -> 생성할 인스턴스

## 함수 호출 방식과 this
1. 일반 함수 호출 -> 전역 객체

2. 메서드 호출 -> 메서드 호출한 객체

3. 생성자 함수 호출 -> 생성할 인스턴스

4. apply, call, bind로 간접 호출
  - 함수가 상속받아 사용 가능
  **- apply, call -> this로 사용할 값을 전달하면서 함수를 호출**
  - apply -> 인수를 배열로 넘기기
  - call -> 인수를 쉼표로 구분한 리스트로
  - bild -> 함수 호출X, this 연결할 값을 전달하여 새로운 함수 반환

# 23장: 실행 컨텍스트
- 실행할 코드에 제공할 관경 정보들을 모아놓은 객체

-> 소스코드 실행에 필요한 정보, 변수나 함수를 실행컨텍스트 내 스코프에서 검색

## 소스코드에 따라 실행컨텍스트 생성 과정이 달라짐!

- 전역 코드, 함수 코드, eval 코드, 모듈 코드 실행될 때 각각의 실행 컨텍스트가 구성됨

- 실행 컨텍스트는 무엇이고 어떤 역할을 하는가!?

  - 모든 코드는 실행 컨텍스트에 의해 실행되고 관리됨

  - 실행 컨텍스트 스택 -> 코드 실행 순서 관리(스택 방식으로)

  - 소스코드 평가 -> 실행 컨텍스트 생성

## 렉시컬 환경 

- 실행 컨텍스트를 구성하며 **스코프와 식별자를 관리**

  - 스코프를 구분하여 식별자를 등록 및 관리 하는 저장소 역할

  - 구성

    1. 환경 레코드 -> 스코프 내 **식별자**와 그에 해당하는 **값**을 관리하는 저장소
    2. 외부 렉시컬 환경에 대한참조 -> 해당 실행 컨텍스트를 포함하는 **상위 스코프를 가리킴**

## 전역 코드 평가

1. 전역 실행 컨텍스트 생성

    - 스택의 최상위 => 현재 실행 중인 실행 컨텍스트

2. 전역 렉시컬 환경 생성

    - 전역 실행 컨텍스트에 바인딩

    2-1. 전역 환경 레코드 생성
    - 전역 스코프 역할 -> var와 let, const를 구분해줌(var는 전역객체에 바인딩됨)

      2-1-1. 객체 환경 레코드 생성
        - var, 함수 선언문 by BindingObject, 전역 객체의 프로퍼티와 메서드가 됨
        - var -> 선언, 초기화 동시에 진행 -> 전역 객체의 등록됨 -> 코드 실행 전 참조 시 **undefined 반환** => 변수 호이스팅 원인

        - function ~ -> 평가할 때 **전역 객체로 즉시할당** -> 함수 선언문 이전에 호출O

      2-1-2. 선언적 환경 레코드 생성
        - let, const로 선언한 전역 변수 등록 및 관리
        - let, const -> 전역 객체X instead (개념적인 블록 === 선언적 환경 레코드)에 존재
        - **선언, 초기화가 분리해서 진행됨** -> 초기화(런타임 실행) 전까지 일시적 사각지대에 빠짐 => 똑같이 호이스팅이 진행되지만, 런타임 전까지 참조X

    2-2. this 바인딩
      - this 참조할 때 -> 전역 환경 레코드 `[[GlobalThisValue]]`에서 참조

    2-3. 전역 외부 렉시컬 환경에 대한 참조
      - 상위 스코프 가리킴, 전역 렉시컬 환경은 스코프 체인의 종점 => 참조 null이 할당됨, 식별자가 없을 경우 => type error

## 함수 코드 평가

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성

  2.1. 함수 환경 레코드 생성

  2.2. this 바인딩

  2.3. 외부 렉시컬 환경에 대한 참조

- 전역 코드 실행된 함수의 외부 렉시켤 환경 참조는 전역 렉시컬 환경의 참조

- 함수 정의 위치에 따라 상위 스코프 결정됨

- 함수 평가하고 생성시 `[[Environment]]` 내부 슬롯이 만들어지는데 이것이 상위 스코프를 나타냄

- 함수 안에서 호출된 console 식별자는 현재 함수 렉시컬 환경에서 검색X

  -> 외부 렉시컬 환경 참조가 가리키는 상위 스코프로 이동하여 검색 결국, 전역 렉시컬 환경까지!

- 블록 레벨 스코프

  1. var 키워드 -> 오직 함수 코드만 지역 스코프로 인정
  2. let, const 키워드 -> 모든 코드 블록을 지역 스코프로 인정

  - 전역 코드 평가시에는 블록 레벨 스코프에 따라 환경 레코드를 구분해줘야함. 하지만 함수 코드 평가시에는 그럴 필요 없음 - var, let, const 모두 함수 지역 스코프로 인정

  - let 변수를 if 문에서 정의했을 때

    -> 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성 기존 렉시컬 환경 대체

    -> 코드 블록에 대한 독립적인 렉시컬 환경을 생성 => 클로저 개념으로 이어짐

# 24장 클로저

- 렉시컬 스코프 - 상위 스포크에 대한 참조는 함수가 정의되는 위치에 따라 결정됨

- 함수가 정의 될 때 `[[Environment]]` 슬롯에 렉시컬 환경 참조는 상위 스코프를 가리킴

- 객체 내부 슬롯 `[[Environment]]` 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조 => 상위 스코프 

- 외부 함수가 중첩 함수보다 주기가 짧고 중첩 함수가 외부 함수의 변수를 참조하는 경우의 중첩함수는 클로저

  > 이것이 되는 이유는 실행 컨텍스트가 제거 되더라도 렉시컬 환경까지 없어지지는 않음

  > 중첩함수가 참조한다면 GG가 렉시컬 환경을 지우지 않는다.

외부함수보다 중첩함수가 먼저 소멸되는 경우 -> 클로저X

# 클로저의 활용

## 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용해줌

- 즉시실행함수를 이용 해서 함수를 반환
- 즉시실행함수 안에서 변수 생성시 전역X -> 변수의 의도치 않은 변경이 발생하지 않음
- 즉시실행함수의 내부함수는 즉시실행함수의 실행컨텍스트의 렉시컬 환경을 기억하는 클로저X
- 외부의 예기치 못한 상태 변경을 피하기 위해 함수형 프로그래밍에서 적극적으로 사용됨
- cf) 고차함수: 보조 함수를 인자로 전달받고 함수를 반환하는 함수

## 유의사항
- 클로저를 만드는 함수를 두 번 생성할 경우 할당된 함수는 각각 자신의 독립된 렉시컬 환경이 만들어지기 때문에 자유변수 연동이 되지 않는다.

## 캡슐화
- 프로퍼티와 메서드를 묶는 것
- 목적 -> 특정 프로퍼티와 메서드를 은닉

## 주의사항
- let이나 const를 사용하는 반복문에서는 반복시마다 새로운 렉시컬환경을 생성함
- 독립적인 렉시컬 환경이 만들어지므로 식별자의 값이 유지됨
- 그러나 반복문 안에 함수가 없을시 아무도 참조하지 않기 때문에 GG 대상이됨
