220524

# 14장 전역 변수의 문제점

## 전역 변수의 문제점

- 암묵적 결함: 모든 코드가 전역 변수를 참조하고 변경할 수 있음
  -> 1. 변수의 유효범위가 크면 가독성이 나빠짐
  -> 2. 의도치 않은 상태 변화가 발생할 수 있음

- 긴 생명 주기
  -> 1. 메모리 리소스를 오랜 기간 잡아먹는다.(브라우저 상에서는 브라우저가 닫힐 때까지)
  -> 2. var는 특히 재할당이 가능하기 때문에 의도와는 다르게 값이 바뀔 수 있다.

- 스코프 체인 상 종점에 존재
  -> 변수 검색 시 가장 마지막에 검색됨

- 네임스페이스 오염
  -> 파일이 분리되어 있어도 하나의 전역 스코프 공유하기 때문에 문제 발생 가능성 있음 \*

## 전역 변수의 사용을 억제할 수 있는 방법

1. 즉시 실행 함수
   -> 모든 코드를 즉시 실행 함수로 감싸면 변수를 지역변수로 만들 수 있다.

2. 네임스페이스 객체
   -> 객체 안에 객체를 만들어 계층적으로 구성, 스코프를 줄일 수 있다.
   but, 네임스페이스 객체 자체가 전역 변수에 할당되므로 그닥.

3. 모듈 패턴 like 클래스
   변수와 함수를 모아 즉시 실행 함수로 감싸서 모듈을 만듦

- - 전역 변수의 억제 + 캡슐화

# 15장

## var

- 변수의 중복 선언 허용
- 함수 레벨 스코프(지역변수로 할당시) -> 함수 이외에선 전역변수로

## let

- 변수 중복 선언 금지 -> 같은 스코프 내 중복선언X
- 모든 코드블록을 지역스코프로 인정
- 호이스팅 발생X 처럼?! -> '선언단계', '초기화단계' 분리 -> 스코프 시작부터 초기화 이전까지 사용X
- 전역 객체(window) 프로퍼티X

## const

- 상수 선언 위해서
- const는 선언과 초기화 동시에
- 재할당X -> 원시 값 할당시 값 바뀌지 않음, 코드 가독성도 상승(의미부여)
- 객체는 값 변경 가능(참조형 데이터이기 때문에)

220525

# 8장: 제어문

## 알게된 것

> 문은 변수할당 불가능
> 식 -> 값으로 평가 할 수 있는 문 => 변수에 할당 가능!
> so, 삼항연산자는 표현식이므로 변수의 할당 가능!

## 블록문

- 0개 이상의 문을 중괄호로 묶은 것
- 블록문의 끝에는 자체적으로 종결의 의미가 있어 세미콜론을 붙이지 않음

## 조건문

- if ... else 문 -> 조건식의 평과 결과에 따라 불록문 실행, 조건이 불리언일 때 많이 사용
- switch 문 -> 표현식 평가 후 case 문으로 실행 흐름을 옮김, 표현식이 문자열이나 숫자열일 때 많이 사용

## 반복문

- for 문 -> 조건식이 거짓으로 평가될 때까지 코드 블록 반복, 반복 횟수가 정해져있을 때 많이 사용
- while 문 -> 조건식의 평가 결과가 참이면 코드 블록 반복, 반복 횟수가 정해져있지 않을 때 많이 사용

## break 문

- 코드 블록을 탈출

## continue 문

- 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름으 옮김

# 16장: 프로퍼티와 어트리뷰트

## 내부 슬롯, 내부 메서드

- JS의 엔진의 구현 알고리즘 설명을 위해 사용
- 직접 접근 불가능

## 프로퍼티 어트리뷰트, 프로퍼티 디스트립터 객체

- JS 엔진 -> 프로퍼티 생성 -> 프로퍼티 어트리뷰트 정의(프로퍼티의 상태): JS 엔진이 관리하는 내부 슬롯 - 직접 접근X
- 간접 접근 -> object.getOwnPropertyDescriptor(객체, 키) -> 프로퍼티 디스크립터 객체 반환(프로퍼티 어트리뷰트의 정보 제공)

## 데이터 프로퍼티

- 키, 벨류 값으로 구성
- value, writable, enumerable, configurable 프로퍼티 어트리뷰트를 가짐

## 접근자 프로퍼티

- 자체적 값X, 데이터 프로퍼티 값 읽거나 저장할 때 호출됨
- get, set, enumerable, configurable
- 데이터 프로퍼티 안에 있는 프로퍼티 -> 접근자를 통해 값을 읽거나 저장할 수 있음

=> 둘 구분 어떻게?

- object.getOwnPropertyDescriptor가 반환한 디스크립토 객체 확인

## 프로퍼티 정의?

- 프로퍼티 정의할 때 프로퍼티 어트리뷰트 선택 가능! (Object.defineProperty)

  > enumerable: false => 열거X(for ...)
  > writable: false => 값 변경X
  > configurable: false => 삭제X, 재정의X

- Objec.defineProperty로 프로퍼티 정의시 일부 어트리뷰트 생략가능

## 객체 변경 방지

- 객체는 변할 수 있는 값이기 때문에 변경 방지하는 메서드가 있음!
  > 확장X(객체확장X): Object.preventExtensions: 추가 금지(2가지: 동적, defineProperty), 삭제는 가능
  > 재정의X(객체밀봉): Object.seal -> 읽기와 쓰기만 가능
  > 읽기만 가능(객체 동결): Object.isFrozen
  > 중첩객체 동결(불변 객체): 재귀적 Object.freeze

## 정리 & 배운것

- 프로퍼티는 프로퍼티 상태를 나타내는 어트리뷰트를 가지고 있고 개발자는 그것을 원하는 대로 설정 가능 => 객체를 만들 때 원하는 대로 옵션을 선택할 수 있다!
- 마치, 스타크래프트에서 커세어는 공중 공격만 가능하고, 벌쳐는 지상 공격만 가능하다. 질럿은 근거리 공격만 되고, 마린은 원거리, 공중 다됨. 게임 유닛의 속성을 다르게 만들었듯이 객체도 속성을 다르게 설정 가능하다!

220527

# 17장: 생성자 함수에 의한 객체 생성

## 객체 생성 방식

1. 객체 리터럴로 생성

- 문제
  - 동일한 프로퍼티를 가진 객체를 여러 개 생성해야하는 경우 비효율적

2. new 연산자(생성자 함수)로 생성

- 장점
  - 프로퍼티 구조가 동일한 객체를 여러 개 생성할 때 간편

## 생성자 함수와 인스턴스

> 인스턴스 생성 과정

- 생성자 함수 역할
  1. 인스턴스 생성하기 위한 템플릿 역할
  2. 인스턴스를 초기화 하는 역할(프로퍼티 추가 or 초기값 할당)
- 생성자 함수를 호출하면 암묵적으로 인스턴스 생성 후 반환

1.  인스턴스와 this 바인딩

- 빈 객체가 생성되는데 그것은 인스턴스이다.
- 인스턴스는 this에 바인딩 된다.

2. 인스턴스 초기화

- 프로퍼티 추가 및 생성

3. 인스턴스 반환

- 암묵적으로 인스턴스가 바인딩된 this를 반환

`생성자 함수 내부에서는 return 생략!`

## 내부 메서드

- 함수는 객체이고 객체의 내부슬록과 내부메서드를 가지고 있다.
- 그리고 함수는 `[[Call]]`, `[[Constructor]]]`도 추가로 가지고 있는데
- 일반 함수는 호출 가능하기 때문에 call을 항상 가지고 있고 constructor는 선택

> constructor 구분

- constructor -> 함수 선언문, 함수 표현식, 클랙스
  ```
  // 함수 선언문
  function sum(a, b) {
    return a + b;
  }
  ```
  ```
  // 함수 선언문
    function sum(a, b) {
      return a + b;
    }
  ```
- non-constructor -> 메서드, 화살표 함수
  - 프로퍼티로 정의된 함수는 메서드로 인정X(일반 함수)

> new 연산자

    - 일반 함수의 return 문이 있다면 new 연산자로 인스턴스 생성시 빈 객체 반환함
    - 생성자 함수 구분을 위해 보통 생성자 함수는 파스칼 케이스로 명명

> new.target

    - new 연선자로 생성자 함수 호출 -> new.target은 함수 자신을 가리킴
    - 일반 함수로 호출 -> new.target은 undefined
    - 활용 -> new.target으로 new 연산자와 생성자 함수로서 호출했는지 확인 후 재귀 호출로 생성자 함수로서 호출 가능

# 18장: 함수와 일급 객체

## 일급 객체란 무엇인가?!

1. 무명의 리터럴 생성
2. 변수나 자료구조에 저장 가능
3. 함수의 매개변수에 전달 가능
4. 함수의 반환값으로 사용 가능

- 함수는 일급객체!

### 함수와 일반객체와의 차이

1. 함수는 호출 가능하다.
2. 함수 고유의 프로퍼티를 갖는다.

> 함수 고유의 프로퍼티

1. arguments 프로퍼티

- 매개변수로 전달된 인수의 정보를 담고 있는 순회가능한 유사배열객체(함수 내부에서 지역변수 처럼 사용 가능)

2. caller 프로퍼티

- 함수 자신을 호출한 함수를 가리킴

3. length 프로퍼티

- 함수를 정의할 때 선언한 매개변수의 개수를 가리킴

4. name 프로퍼티

- 함수의 이름을 나타냄
- 익명 함수일 때
  es5 -> 빈 배열
  es6 -> 함수 객체를 가리키는 식별자를 값으로 가짐

5. **proto** 접근자 프로퍼티

- 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티

6. prototype 프로퍼티

- 생성자 함수로 호출할 수 있는 함수 객체, constructor만 소유하는 프로퍼티

# 19장: 프로토타입

## 객체지향 프로그래밍

-> 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

> 객체

- 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조
- 상태 데이터(프로퍼티)와 동작(메서드)을 하나의 논리적인 단위로 묶은 복합적인 자로구조
- 고유한 기능을 수행하면서 다른 객체와의 관계성을 가짐

## 상속과 프로토타입

> 상속

- 어떤 객체의 프로퍼티와 메서드를 그대로 넘겨받아 사용할 수 있는 것
- 상속을 통해 중복 제거 - 공통 메서드를 인스턴스를 만들 때마다 생성하면 비효율적
  => 프로포타입으로 상속
  - 생성자 함수의 prototype 프로퍼티에 공통 메서드를 등록할 수 있음
  - 하나의 메서드를 필요할 때마다 상속받아 사용 가능!

## 프로포타입 객체

- 어떤 객체의 상위(부모)객체의 역할을 하는 객체 -> 공유 프로퍼티 제공
- 모든 객체는 `[[prototype]]` 내부 슬롯을 가짐(프로토타입의 참조) -> 객체 생성 방식에 따라 프로토타입 다름
- (`[[prototype]]` 안에 프로토타입이 저장됨)
  - 일반 객체 경우 -> 프로토타입은 Object.prototype
  - 생성자 함수의 경우 -> 생성자 함수의 prototype 프로퍼티에 있는 객체

> **proto** 접근자 프로퍼티

- 자신의 `[[prototype]]` 접근하기 위해 **prototype**을 간접적으로 사용할 수 있음
- 모든 객체는 **proto**를 통해 `[[prototype]]`에 간접적으로 접근 가능!(**proto** -> 프로토타입)
- 접근자 프로퍼티는 자체 값X, get/set 프로퍼티 어트리뷰트로 구성
- **proto** -> 값 지정: get, 값 할당: set
- Object.prototype의 프로퍼티(객체들이 공통으로 소유하는 것) -> 어던 객체의 프로퍼티가 없다면 타고타고 올라가 Object.prototype이 검색된다(프로포타입 체이닝)

> 프로토타입에 접근하려는 이유

- 상호참조에 의해 프로토타입 체인이 생성되는 것 막기 위해
- 프로토타입 체인은 단방향 링크드 리스트로 구현되어야함!

> **proto**로 접근 권장X -> 모든 객체가 **proto** 사용 가능X
> -> getPrototypeOf 메서드를 사용할 것

> 함수 객체의 prototype 프로퍼티

- 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킴
- non-constructor는 prototype 프로퍼티가 없다

> 모든 객체 -> **proto** - 객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용
> 함수 객체(constructor) -> prototype 프로퍼티 - 인스턴스의 프로토타입을 할당하기 위해 사용

> 프로토타입의 constructor 프로퍼티와 생성자 함수
> 인스턴스 -> prototype(constructor를 가짐) -> 생성자 함수

=> 인스턴스는 prototype의 constructor를 상속받아 사용 가능

## 프로토타입의 생성 시점

> 리터럴로 생성된 객체의 생성자 함수와 프로토타입은 쌍으로 존재하기 때문에 => 프로토타입은 생성자 함수가 생성되는 시점에 같이 생성된다.

## 빌트인과 사용자 정의 함수 프로토타입 생성 시점

> 사용자 정의 함수

- 생성자 함수 가장 먼저 실행 -> 함수 객체가 됨 -> 프로토타입도 같이 생성 -> 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩 됨
- 생성된 프로토타입은 언제나 Object.prototype

> 빌트인 생성자 함수

- 전역 객체가 생성되는 시점(코드실행전)에 프로토타입 생성됨! -> 생성된 프로토타입은 prototype 프로퍼티에 바인딩 됨
- 객체 생성 전 이미 생성자함수 프로토타입 존재하고 생성자 또는 리터럴로 객체가 생성하면 프로토타입은 해당 객체의 `[[Prototype]]` 내부슬롯에 할당됨

## 객체 생성방식과 프로토타입 결정

- OrginaryObjectCreate - 프로토타입을 만들어 객체에 전달해줌
- 프로토타입은 추상 연산 OrginaryObjectCreate에 전달되는 인수에 의해 결정됨

> 객체 생성방식에 따른 프로퍼티 추가 방식 차이

- 객체리터럴 -> 객체 리터럴 내부에 프로퍼티 추가
- 생성자함수 -> 일단 빈객체 생성, 프로퍼티 추가

## 프로토타입 체인

- JS가 객체지향 프로그래밍의 상속을 구현하는 메커니즘
- 객체의 메서드에 접근하려 할 때 `[[prototype]]` 내부 슬롯의 참조를 따라서 부모쪽으로 순차적으로 검색
- 프로토타입 체인을 통해 부모자식간 상속과 검색을 할 수 있음!
- 프로퍼티말고 식별자는 스코프 내에서 검색함!(스코프 체인 -> 스코프의 계층적 구조)
- 스코프 체인과 프로토타입 체인은 서로 협력하여 식별자와 프로퍼티 검색!

## 오버라이팅과 프로퍼티 섀도잉

- 상속관계에 의해 프로퍼티가 가려지는 현상

  - 프로토타입 메서드, 인스턴스 메서드

- 하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제 불가능
  (하극상X, 프로토타입에 직접 접근)

## 프로토타입 교체

1. 생성자 함수로 교체-> 객체 리처럴로 교체 -> constructor 없음
2. 인스턴스로 교체 -> `__proto__`를 통해 접근

## instanceof 연산자

- `객체 instanceof 생성자 함수`
  -> 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상 존재하는지

## 직접 상속

> Object.create 메서드: 객체를 생성하면서 직접적으로 상속 구현

> `__proto__` 로 상속: 객체 리터럴 내부에서 `__proto__` 접근자로 직접 상속 가능

## 정적 프로퍼티와 메서드

- 생성자 함수로 인스턴스를 생성하지 않아도 참조할 수 있는 프로퍼티와 메서드
  -> .staticMethod() - .함수() 형식으로 호출하는 함수

- 생성자 함수가 생성한 인스턴스로 참조 불가능 -> me.staticMethod() => 에러
  -> 정적 프로퍼티/메서드는 인스턴스의 프로토타입 체인에 속한 것이 아니므로 인스턴스로 접근X

- 프로토타입 메서드를 호출 하려면 -> 인스턴스 생성해야함 but 정적 메서드를 호출은 -> 인스턴스 생성 안해도됨!

## 프로퍼티 존재 확인

- in 연산자, Object.prototype.hasownProperty() 통해 객체 내 특정 프로퍼티 존재 여부 확인 가능!

## 프로퍼티 열거

> for ... in

- 객체의 모든 프로터치를 순회하며 열거, 열거문 안에 선언한 변수의 프로퍼티 키를 할당!
- 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 eumerable한 프로퍼티를 열거
- 객체 자신 프로퍼티 + 상속받은 프로퍼티도 열거
- 프로퍼티 열거시 순서보장X

> Object.keys.entries 메서드를 통해 자신의 고유한 프로퍼티만 열거 가능하다.

## ESLint

- 린트 도구는 코드를 점검하는 툴이다.
- 소스코드 실행 전 문법적 오류 + 잠재적 오류까지 확인해줌

# 21장: 빌트인 객체

> 표준 빌트인 객체, 호스트 객체, 사용자 정의 객체

## 표준 빌트인 객체

- 인스턴스를 생성할 수 있는 생성자 함수 객체 -> 프로토타입 메서드 + 정적 메서드

```JS
const numObj = new Number(1.5); // Number {1.5}
console.log(numObj.tofixed()); // 2
console.log(Number.isInteger(0.5)) // false
```

## 원시값이 객체처럼?

```JS
const str = 'hello';
console.log(str.length); // 5
console.log(str.toUpperCase()); // HELLO
```

- 마침표 표기법 사용시 **JS엔진이 원시 값을 연관된 객체로 변환하고 다시 되돌림!**
- 상속받을 수도 있음!(임시객체인 **래퍼 객체** 적용)
- 그래서 String, Number, Boolean은 생성자 함수로 사용하는 것은 권장X

## 전역 객체

- 어떤 객체에도 속하지 않는 모든 빌트인 객체의 최상위 객체
- 전역 객체의 프로퍼티
  - var 전역 변수 -> 전역 변수X, 전역 객체의 프로퍼티
  - 암묵적 전역
  - 전역 함수

## 빌트인 전역 함수

> ecncodeURI -> 이스케이프 처리하여 인코딩

- 아스키 문자 셋으로 변환하여 모든 시스템에서 읽을 수 있게 처리!
- 한글은 URL에 적용X, 한글을 인코딩하면 이스케이프 처리됨

## 암묵적 전역

- 마치 선언된 전역 번수처럼 동작 -> 전역 객체의 프로퍼티가 됨!
- but 변수X -> 호이스팅X'
- delete로 삭제O

# 22장: this

## this 키워드!

- 생성할 인스턴스를 가리치는 특수한 식별자!
- 생성자 함수를 정의할 때는 인스턴스 정의하기 전! -> 그래서 식별자가 필요함

- 특징
  - this에 연결되는 것은 함수 호출 방식에 동적으로 결정됨!
  - 객체 리터럴 메서드 내부 -> 메서드 호출한 객체
  - 생성자 함수 내부 -> 생성할 인스턴스

## 함수 호출 방식과 this

1. 일반 함수 호출 -> 전역 객체

2. 메서드 호출 -> 메서드 호출한 객체

3. 생성자 함수 호출 -> 생성할 인스턴스

4. apply, call, bind로 간접 호출

- 함수가 상속받아 사용 가능
  **- apply, call -> this로 사용할 값을 전달하면서 함수를 호출**
- apply -> 인수를 배열로 넘기기
- call -> 인수를 쉼표로 구분한 리스트로
- bild -> 함수 호출X, this 연결할 값을 전달하여 새로운 함수 반환

# 23장: 실행 컨텍스트

- 실행할 코드에 제공할 관경 정보들을 모아놓은 객체

-> 소스코드 실행에 필요한 정보, 변수나 함수를 실행컨텍스트 내 스코프에서 검색

## 소스코드에 따라 실행컨텍스트 생성 과정이 달라짐!

- 전역 코드, 함수 코드, eval 코드, 모듈 코드 실행될 때 각각의 실행 컨텍스트가 구성됨

- 실행 컨텍스트는 무엇이고 어떤 역할을 하는가!?

  - 모든 코드는 실행 컨텍스트에 의해 실행되고 관리됨

  - 실행 컨텍스트 스택 -> 코드 실행 순서 관리(스택 방식으로)

  - 소스코드 평가 -> 실행 컨텍스트 생성

## 렉시컬 환경

- 실행 컨텍스트를 구성하며 **스코프와 식별자를 관리**

  - 스코프를 구분하여 식별자를 등록 및 관리 하는 저장소 역할

  - 구성

    1. 환경 레코드 -> 스코프 내 **식별자**와 그에 해당하는 **값**을 관리하는 저장소
    2. 외부 렉시컬 환경에 대한참조 -> 해당 실행 컨텍스트를 포함하는 **상위 스코프를 가리킴**

## 전역 코드 평가

1. 전역 실행 컨텍스트 생성

   - 스택의 최상위 => 현재 실행 중인 실행 컨텍스트

2. 전역 렉시컬 환경 생성

   - 전역 실행 컨텍스트에 바인딩

   2-1. 전역 환경 레코드 생성

   - 전역 스코프 역할 -> var와 let, const를 구분해줌(var는 전역객체에 바인딩됨)

     2-1-1. 객체 환경 레코드 생성

     - var, 함수 선언문 by BindingObject, 전역 객체의 프로퍼티와 메서드가 됨
     - var -> 선언, 초기화 동시에 진행 -> 전역 객체의 등록됨 -> 코드 실행 전 참조 시 **undefined 반환** => 변수 호이스팅 원인

     - function ~ -> 평가할 때 **전역 객체로 즉시할당** -> 함수 선언문 이전에 호출O

     2-1-2. 선언적 환경 레코드 생성

     - let, const로 선언한 전역 변수 등록 및 관리
     - let, const -> 전역 객체X instead (개념적인 블록 === 선언적 환경 레코드)에 존재
     - **선언, 초기화가 분리해서 진행됨** -> 초기화(런타임 실행) 전까지 일시적 사각지대에 빠짐 => 똑같이 호이스팅이 진행되지만, 런타임 전까지 참조X

   2-2. this 바인딩

   - this 참조할 때 -> 전역 환경 레코드 `[[GlobalThisValue]]`에서 참조

   2-3. 전역 외부 렉시컬 환경에 대한 참조

   - 상위 스코프 가리킴, 전역 렉시컬 환경은 스코프 체인의 종점 => 참조 null이 할당됨, 식별자가 없을 경우 => type error

## 함수 코드 평가

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성

   2.1. 함수 환경 레코드 생성

   2.2. this 바인딩

   2.3. 외부 렉시컬 환경에 대한 참조

- 전역 코드 실행된 함수의 외부 렉시켤 환경 참조는 전역 렉시컬 환경의 참조

- 함수 정의 위치에 따라 상위 스코프 결정됨

- 함수 평가하고 생성시 `[[Environment]]` 내부 슬롯이 만들어지는데 이것이 상위 스코프를 나타냄

- 함수 안에서 호출된 console 식별자는 현재 함수 렉시컬 환경에서 검색X

  -> 외부 렉시컬 환경 참조가 가리키는 상위 스코프로 이동하여 검색 결국, 전역 렉시컬 환경까지!

- 블록 레벨 스코프

  1. var 키워드 -> 오직 함수 코드만 지역 스코프로 인정
  2. let, const 키워드 -> 모든 코드 블록을 지역 스코프로 인정

  - 전역 코드 평가시에는 블록 레벨 스코프에 따라 환경 레코드를 구분해줘야함. 하지만 함수 코드 평가시에는 그럴 필요 없음 - var, let, const 모두 함수 지역 스코프로 인정

  - let 변수를 if 문에서 정의했을 때

    -> 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성 기존 렉시컬 환경 대체

    -> 코드 블록에 대한 독립적인 렉시컬 환경을 생성 => 클로저 개념으로 이어짐

# 24장 클로저

- 렉시컬 스코프 - 상위 스포크에 대한 참조는 함수가 정의되는 위치에 따라 결정됨

- 함수가 정의 될 때 `[[Environment]]` 슬롯에 렉시컬 환경 참조는 상위 스코프를 가리킴

- 객체 내부 슬롯 `[[Environment]]` 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조 => 상위 스코프

- 외부 함수가 중첩 함수보다 주기가 짧고 중첩 함수가 외부 함수의 변수를 참조하는 경우의 중첩함수는 클로저

  > 이것이 되는 이유는 실행 컨텍스트가 제거 되더라도 렉시컬 환경까지 없어지지는 않음

  > 중첩함수가 참조한다면 GG가 렉시컬 환경을 지우지 않는다.

외부함수보다 중첩함수가 먼저 소멸되는 경우 -> 클로저X

# 클로저의 활용

## 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용해줌

- 즉시실행함수를 이용 해서 함수를 반환
- 즉시실행함수 안에서 변수 생성시 전역X -> 변수의 의도치 않은 변경이 발생하지 않음
- 즉시실행함수의 내부함수는 즉시실행함수의 실행컨텍스트의 렉시컬 환경을 기억하는 클로저X
- 외부의 예기치 못한 상태 변경을 피하기 위해 함수형 프로그래밍에서 적극적으로 사용됨
- cf) 고차함수: 보조 함수를 인자로 전달받고 함수를 반환하는 함수

## 유의사항

- 클로저를 만드는 함수를 두 번 생성할 경우 할당된 함수는 각각 자신의 독립된 렉시컬 환경이 만들어지기 때문에 자유변수 연동이 되지 않는다.

## 캡슐화

- 프로퍼티와 메서드를 묶는 것
- 목적 -> 특정 프로퍼티와 메서드를 은닉

## 주의사항

- let이나 const를 사용하는 반복문에서는 반복시마다 새로운 렉시컬환경을 생성함
- 독립적인 렉시컬 환경이 만들어지므로 식별자의 값이 유지됨
- 그러나 반복문 안에 함수가 없을시 아무도 참조하지 않기 때문에 GG 대상이됨

# 25장 클래스

## JS는 생성자 함수와 프로토타입을 통해 객체지향 구현 -> 객체를 만들어냄

## JS에서 클래스는 새로운 객체 생성 방식

## 클래스는 함수다.

- 값처럼 사용할 수 있는 일급 객체

  - 변수나 자료구조에 저장
  - 함수의 매개변수로
  - 함수의 반환값으로

- costructor, 프로토타입 메서드, 정적 메서드

- 호이스팅이 일어남
  - let, const 처럼 TDZ

## 클래스에서 메서드

- constructor, 프로토타입 메서드, 정적 메서드 => 호출 가능
- 클래스는 함수이기 때문에 1. 함수 객체 고유 프로퍼티, 2. 프로토타입고 연결, 3. 자신의 스코프 체인 구성
- constructor
  - constructor는 메서드라기 보다는 기술된 동작을 하는 함수 객체, 별도의 반환문 없어야함 -> this(인스턴스)를 반환하기 때문에
- 프로토타입 메서드
  - 클래스에서 정의한 메서드는 자동으로 프로토타입 메서드가 됨
- 정적 메서드
  - 클래스 내에서 static 키워드를 붙여 정의, 클래스로 호출 해야함!
  - 인스턴스의 프로토타입 체인상에는 클래스가 존재X => 인스턴스로 메서드 상속X
  - 정적 메서드 내부의 this는 인스턴스X, 클래스다!
- 프로퍼티
  - 클래스의 메서드는 프로토타입 메서드가 됨 -> 접근자 프로퍼티는 프로토타입의 프로퍼티

## 상속에 의한 클래스 확장

- 프로토타입 -> 자산 상속 -> 프로토타입 체인을 통해
- 클래스 확장 -> 묻고 더블 -> 클래스 + 클래스 => 새로운 클래스

- extends 키워드를 사용하면 생성자 함수도 확장할 수 있음

- 인스턴스간의 프로토타입 체인 생성, 클래스간 프로토타입 체인 생성

  - => 프로토타입 메서드, 정적 메서드 모두 상속O

- super 키워드
  - 수퍼클래스(상위)의 constructor를 호출하여 인스턴스 생성
  - 서브클래스의 constructor에서 super 반드시 호출해야함 -> 서브클래스의 인스턴스는 사실 super에서 만들어지기 때문에
- 수퍼클래스 -> 서브클래스 인스턴스 생성 과정

1. 수퍼클래스 this에 인스턴스 바인딩
2. constructor가 받은 인수로 인스턴스 초기화
3. super가 반환한 인스턴스가 서브클래스 constructor의 this로 바인딩됨
4. 서브클래스는 별도 인스턴스 생성X, 그대로 받아 사용
   => 서브클래스 constructor는 super 호출 이후 처리해야함!

## 26장: ES6 함수의 추가 기능

### 일반함수 - 함수 선언문, 표현식

### 메서드 - 메서드 축약표현으로 정의된 함수(프로퍼티로 전달된 함수는 메서드X)

- non-constructor -> 생성자함수X -> 인스턴스 생성X -> 프로토타입 프로퍼티X
- super 참조를 위해 자신을 바인딩한 객체 가리키는 `[[homeobject]]`를 가지고 있음

### 화살표 함수

- 함수 표현식으로만 정의
- this 문제 해결
- non-constructor -> 인스턴스X, 프로토타입 프로퍼티X
- this, arguments, super, new.target 바인딩X -> 상위 스코프를 참조
  - 화살표 함수로 메서드정의 하지 말자 -> this가 전역이 되기 때문에

### rest 파리미터

- 함수에 전달된 인수들의 목록을 배열로 전달

  - 마지막 파라미터여야함! - 먼저 전달된 인수의 나머지 값이기 때문에!

- arguments 객체 -> 함수 호출시 전달된 인수의 정보 - 유사배열객체

  - 유사배열객체이므로 따로 배열로 전환해줘야함
  - but, rest 파라미터는 바로 배열로 전달해주기 때문에 배열 전환 과정 생략O
  - 화살표 함수는 arguments 객체 없기 때문에 무조건 rest를 써야함! - 가변인수함수 구현시

- JS엔진은 매개변수 개수와 인수의 개수 체크X

  - 전달X 매개변수는 undefined
    => 기본값을 전달하여 undefined인 경우 처리O
  - rest는 기본값 적용 불가능

- JS의 배열은 객체다
  - 인덱스가 키, 값이 배열의 요소
  - 일반적인 객체와의 차이는 값의순서와 length 프로퍼티
  - 배열이 객체 형식이라는 것의 기능상 의미는 인덱스 접근 보다는 요소 삽입 또는 삭제의 집중(희소 배열)

# 배열

- 배열생성 방식
  1. 배열 리터럴
  2. Array 생성자 함수
  3. Array.of, Array.from 메서드
  - Array.of() - 전달된 인수를 요소로 갖는 배열 생성
  - Array.from - 유사배열객체, 이터러블 객체를 인수로 받아 배열로 변환

### 배열 메서드

> 원본배열을 직접 변경하는 메서드

- .push() -> 성능에 별로 좋지 않음 => length 프로퍼티로 배열의 마지막 요소 추가가능(1개일 경우)
- .pop() -> 마지막 요소 제거, 제거한 요소 반환
  => push, pop을 사용하면 스택 구조 쉽게 구현(후입선출)
- unshift() -> 배열의 앞에 추가하고 length 프로퍼티 반환
- shift() -> 배열의 첫 번째 요소 제거하고 제거한 요소 반환
  => push와 shift를 사용하면 queue 쉽게 구현 가능(선입선출)
- splice() -> 배열 중간의 요소를 추가하거나 제거
  - splice(start, deleteCount, items)
    > 새로운 배열을 생성하여 반환하는 메서드
- .concat() -> 마지막 요소로 추가한 새로운 배열 반환
- .slice() -> 인수로 전달된 범위의 요소들을 복사하여 배열로 반환
  - 인수 없이 상요시 얕은 복사 가능
  - 유사배열객체를 배열로 변환 가능
- .reverse() -> 원본 배열의 순서를 반대로 뒤집음
- .fill() -> 인수로 받은 값을 배열의 처음터 끝까지 반환
- .join() -> 원본 배열의 요소를 문자열로 변환 후, 구분자로 연결한 문자열 반환
  - 인수로 받는 구분자 생략시 기본 구분자는 콤마

### 배열 고차 함수

#### 고차함수 - 함수를 인수로 전달받거나 함수를 반환하는 함수

- 함수형 프로그래밍 최고! - 반복문 조건문의 복잡성을 제거하고 데이터 불변성 지향

  - sort()

    - 유니코드 포인트의 순서를 따름! -> 10이 2보다 빠른 순서
    - 일시적으로 문자열로 변환 후 유니코드 순으로 정렬
      => 비교함수를 통해 정렬! - 비교함수는 음수, 0, 양수 반환
      - 양수 -> 첫번째 인수부터, 0 -> 정렬X, 음수 -> 두번째 인수부터
    - 객체를 요소로 갖는 배열도 정렬 가능!

  - forEach()

    - 반복문을 총해 배열 순회하면서 콜백 함수를 받아 반복 호출하여 처리
    - 3개의 콜백함수 인수를 전달 1. 요소값, 2. 인덱스, 3. this
    - 배열의 요소 모두 순회, 중간에 순회를 멈출 수 없음
    - 순회시 희소배열은 제외
    - 언제나 undefined를 반환

  - map()

    - 배열의 모든 요소 순회 -> 콜백 함수 실행 -> 새로운 배열 반환
    - 요소값을 다른 값으로 매핑할 때 쓰임!
    - this 값을 따로 받을 수 있음 보통 화살표함수로 this 인수 전달을 생략함

  - filter()

    - 콜백함수 반환값이 true인 요소만 새로운 배열로 반환
    - 배열에서 특정 요소를 제거하기 위해 사용하기도 함! -> 중복된 요소 모두 제거됨
    - 특정 요소만 제거 -> indexOf로 인덱스 찾고 splice로 제거

  - reduce()
    - 콜백 함수의 반환값을 다음 순회 시 첫 번째 인수로 전달하면서 결국 하나의 결과값 반환
    - reduce(콜백함수(누적값, 요소값, 현재인덱스, 호출한배열), 누적값의 초기값.)

  > 중복요소 제거

  - reduce()
  - filter()
  - Set

  - some()

    - 콜백 함수의 반환값이 단 하나라도 참이면 true 반환

  - every()

    - 콜백 함수 반환값이 모두 참이면 true 반환

  - find()

    - 콜백 함수 반환값이 true인 첫번째 요소 반환 없으면 undefined
    - 반환값이 해당 요소의 값 꼭 배열이 아님

  - findIndex()
    - 콜백 함수 반환값이 true인 첫번째 요소 인덱스 반환 없으면 -1

# 28장: Number

## new Number의 인수는 number 래퍼객체가 생성됨

- > 래퍼객체: 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시객체
- Number로 인수의 값은 숫자로 강제변환되어 `[[NumberData]]` 슬롯에 할당된 Number 래퍼객체가 생성

## Number 프로퍼티

- Number.EPSILON
  - 1과 1보다 큰 숫자 중에서 가장 작은 숫자와의 차이
  - > 부동소수점: 실수를 컴퓨터상에서 근사하여 표현하는 방식

## 메서드

- Number.isNaN -> 암묵적 타입변환(X)
- .isNaN -> 암묵적 타입변환(O, 인수를 숫자로 바꿈)
- Number.toExponential -> 숫자를 지수표기법으로 문자열로 반환
- 숫자뒤에 '.' 의 의미
  - 부동소수점
  - 소수 구분 기호
    => 괄호나 공백 뒤 .을 입력

# 29장: Math

- 수학적인 상수와 함수를 위한 정적 메서드와 정적 프로퍼티 제공, 생성자함수X

## Math 메서드

- Math.random()
  - 0에서 1미만의 난수
- Math.pow()
  - Math.pow(2, 3) => 2의 세제곱 반환
- Math.Max()
  - Math.max(...[1, 2, 3]) // 배열일 때는 스프레드 연산자 활용

# 30장: Date

- 날짜와 시간을 위한 메서드를 제공하는 빌트인 객체 && 생성자함수
  > Date 생성자 함수로 Date 객체 생성

1. new Date() -> 현재 날짜와 시간을 가진 Date 객체 반환
2. Date() -> 현재 날짜와 시간을 문자열로 반환(Date 객체X)
3. new Date(dateString) -> 날짜 시간을 나타내는 문자열을 Date 객체로 반환
4. new Date(year, month, [daty, hour ...]) -> 입력한 값에 맞는 Date 객체 반환

# 31장: RegExp

> 정규표현식 -> 패턴 매칭기능 제공, 일정 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어

- 패턴과 플래그로 구성

- 정규 표현식 생성

  1. 정규 표현식 리터럴 -> `const = regexp = /JS/gi`
  2. RegExp 생성자 함수 -> `new RegExp(pattern, [,flag])`

- 패턴
  - .
  - {m, n}
  - |
  - -
  - [^]
  - $
  - ^[]

# 32장: String

- new 연산자와 함께 호출시 -> string 래퍼객체 생성됨

  - length 프로퍼티가지고 이터러블함

- String 메서드

  - 원본 String 래퍼객체를 변경하는 메서드 없음
  - 왜냐하면 변경된 Stirng 래퍼 객체를 다시 문자열로 돌릴 때 원본 문자열이 변경되기 때문에

  > 공백문자 제거

  - String.prototype.replace 메서드
    -> 정규표현식을 인수로 사용하여 공백 문자 제거 가능
  - .trimStart, .trimEnd
    -> 앞뒤 공백문자 제거됨

  > replace의 두번째 인수

  - 두번째 인수의 함수를 넣어 첫번째 인수로 인한 결과값을 그 함수의 인자로 넣을 수 있음!

# 33장: Symbol

- 심벌(symbol): 변경 불가능한 원시 타입
- 주로 유일한 프로퍼티 키를 만드려고 사용
- symbol() 함수를 통해서만 생성가능(생성자함수X)

# 34장: 이터러블

- 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일 시킴
  -> for ...of, 스프레드 문법, 배열 구조분해할당 가능

- 이터러블

  1. Symbol.iterator
  2. 프로토타입 체인으로 상속 받은 객체

- 이터레이터

  - Symbol.iterator 메서드 호출 -> 이터레이터 반환(next 메서드 가짐)
  - next 메서드는 포인터 역할을 하며, result 객체를 반환함
  - next는 value와 done 프로퍼티를 가짐
    - value는 현재 순회중인 이터러블 값
    - done은 순회 완료 여부

- 빌트인 이터러블

  - Array
  - String
  - Map
  - Set
  - DOM 컬렉션
  - arguments
  - TypedArray

- for ...of

  - 이터러블을 순회하며 요소 변수에 할당
  - next 메서드가 반환하는 value 값을 변수에 할당
  - done이 true이면 순회 종료

- 유사배열객체는 이터러블 ?!

  - 유사배열객체 -> 인덱스로 프로퍼티 접근 & length 프로퍼티 갖는 객체
  - 기본적으로 유사배열객체는 객체이므로 이터러블X, for ..of 사용X
  - but argumnets, NodeList, HTMLCollection 은 이터러블이면서 유사배열객체
  - 유사배열객체이지만 이터러블이 아닌 것은 Array.from을 통해 배열로 변환 가능

- 이터레이션 프로토콜

  - 데이터 소비자가 데이터를 일률적이고 효율적으로 사용할 수 있게 해줌(통일된 규약이 있기 때문에)

- 무한 이터러블, 지연 평가
  - 무한 이터러블로 무한 수열 구현 가능
  - 지연평가 -> 데이터 로직만 먼저 구현하고 데이터 필요시 그때서야 생성
    - next 메서드를 호출하지 않으면 데이터 생성하지 않음
    - 실행속도 빠르고 메모리 낭비 줄임

# 35장: 스프레드 문법(...)

- 뭉쳐 있는 값들을 펼쳐서 개별 목록을 만들어줌
- 이터러블이면 사용 가능!(일반 객체는X)
- 스프레드 문법의 결과는 값이 아니기 때문에 변수 할당X

> 어디서 사용?

1. 함수 호출문의 인수 목록

- 예시

  ```js
  const arr = [1, 2, 3]
  const max = Math.max(...arr)

  function foo(...rest) {
    console.log(rest) /// [1, 2, 3]
  }
  foo(...[1, 2, 3])
  ```

- Rest 파라미터 -> 인수 목록을 배열로 전달
- 스프레드 문법 -> 뭉쳐 있는 배열을 목록으로 만듦

2. 배열 리터럴의 요소 목록

- concat, splice(요소 추가, 제거), 배열 복사, 이터러블을 배열로 변환
  - 이터러블X 유사배열객체 -> 스프레드 사용X -> Array.from()
  - 이터러블O 유사배열객체 -> 스프레드 사용O(arguments)

3. 객체 리터럴의 프로퍼티 목록

- 새로 제안된 스프레드 프로퍼티 -> 일반객체도 스프레드 문법 적용O

# 36장: 디스트럭처링 할당

- 이터러블 또는 객체를 1개 이상의 변수에 개별적으로 할당
- 즉, 원하는 값만 추출해서 쓸 수 가 있음!

> 배열 디스트럭처링 할당

- 할당 기준은 **배열의 인덱스**! -> 순서대로 할당됨!
- 요소 개수 상관X
- 변수에 기본값 설정 가능!
  `const [one = 1, two, three] = arr`

> 객체 디스트럭처링 할당

- 할당 기준은 **프로퍼티 키**! -> 순서 의미X
- 변수에 기본값 설정 가능!
- 함수에 매개변수에도 가능
  ```js
  const user = { firstName: 'Elon', lastName: 'Musk' }
  const { lastName, firstName } = user
  ```

# 37장: Set

- 중복되지 않는 유일한 값의 집합! - 수학적 집합 구현을 위한 자료구조
  - 교집합, 합집합, 차집합, 여집합 등을 구현할 수 있다!
- 배열과 유사 but -> 중복X, 순서 의미X, 인덱스 접근X

# 38장: map

- 키와 값의 쌍으로 이루어진 컬렉션
- 객체와 유사 but -> 이터러블O, 요소 개수 확인 - Map.size, key 타입 제한X
- new Map(이터러블) -> 인수 이터러블은 키와 쌍으로 이루어진 요소 => Map 객체 생성
- 중복된 값 인수로X
- Map 객체는 이터러블 -> for ...of, 스프레드, 배열 디스트럭처링
